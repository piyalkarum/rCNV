---
title: "rCNV: An R package for detecting CNV from SNPs"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Piyal Karunarathne"
output: rmarkdown::html_vignette
header-includes:
  -\usepackage{titling}
  - \pretitle{\begin{center}
    \includegraphics[width=2in,height=2in]{logo.png}\LARGE\\}
  -\posttitle{\end{center}}
vignette: >
  %\VignetteIndexEntry{rCNV}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(rCNV)
```

# **rCNV: An R package for detecting copy number variants from SNPs data**
`r rCNV:::colorize("Piyal Karunarathne, Qiujie Zhou, and Pascal Milesi","dodgerblue")`


This tutorial will provide and A-Z guide to detecting CNVs from SNPs data. This includes importing raw VCF files, filtering VCFs, normalization of read depth, categorization of SNPs into "duplicates" and "singlets".

All the data used in this tutorial is available either withing the package or from the GitHub repository at <link>.

## 1. PRE-DETECTION
### 1.1 Importing data
|     Raw VCF files can be imported to rCNV R environment using the built-in function *readVCF()*. The imported vcf is stored as a data frame within a list. 
```{r, eval=FALSE}
# Start by installing the package if you haven't already done so.
if (!requireNamespace("devtools", quietly = TRUE)) 
    install.packages("devtools") 
devtools::install_github("piyalkarum/rCNV", build_vignettes = TRUE)
```

```{r, echo=T,eval=TRUE}
vcf.file.path <- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf <- readVCF(vcf.file.path,verbose = FALSE)
```
```{r,eval=FALSE}
#print the first 10 rows and columns of the imported VCF
vcf$vcf[1:10,1:10]
```
```{r, echo=FALSE}
vcf$vcf[1:6,c(1:7,9,10)]
```

### 1.2 Filtering VCF for missing data
|       The raw VCF files often contain missing data for both samples and SNPs. If retained, these samples and SNPs can introduce false positives and negatives to the analysis. Therefore, they must be removed based on a missing percentage. The function *get.miss()* determines the missing percentages in samples and SNPs and graphically visualize the missing ranges with 5% quantile values. We recommend removing samples and SNPs with missing percentages higher than 50%.
The following example demonstrates such filtering on Parrot Fish data from *McKinney et al. (2017)*.

```{r,echo=TRUE,eval=TRUE,fig.dim=c(6,4)}
parrot<-readVCF("../testDATA/Parrotfish_sequenceReads.vcf",verbose=F)
mss<-get.miss(parrot,verbose = F, plot=F)
```
This generates list with missing percentage tables for SNPs and samples and the Fig 1.2 where missing percentages are plotted. Users can also manually plot these percentages on their discretion. Further, if desired one type of missing percentage (i.e. per sample or per SNP) can calculated separately by specifying the argument *type=* in the *get.miss* function. See the help page of *get.miss* for more information.

![Fig.1.2. Missing status of the VCF](get.miss.jpeg){width=80%}
```{r}
head(mss$perSample)
```

The plot shows that there are several samples with missing data for more than 50% of the SNPs. It is recommended to remove these before proceeding with further analysis. Removing them from the imported vcf file is just a matter of obtaining the columns (samples) for which missing percentage if >50%.

```{r}
dim(parrot$vcf)
sam<-which(mss$perSample$f_miss>0.5)+9 #here we determine the sample columns with f_miss>0.5 and add 9 to get the correct column number
parrot<-data.frame(parrot$vcf)[,-sam]
dim(parrot)
```
We have removed 5 samples that were undesired for the analysis due to their missing data.
Undesired SNPs can also be removed the same way; Hint: now they are in rows.

## 1.3 Assessing the relatedness among samples and heterozygosity withing

The function *relatedness()* in the rCNV package will generate the relatedness index between pairs of samples according to *Yang et al. (2010)*.
The output is a data frame with pairs of samples and the relatedness score *Ajk*. Please read *Yang et al. (2010)* for more information on the calculation of *Ajk*.

```{r,fig.dim=c(6,4),eval=FALSE}
rels<-relatedness(parrot)
head(rels)
```

From the relatedness plots, we can see that the relatedness in Parrot fish samples is low. We recommend removing one sample of the pairs with outlier values above 0.9.

![](relatedness.png){width=40%} ![](h.zygosity.png){width=40%}

Figure 1.3.a Relatedness among samples,b Heterozygosity in Parrotfish populations

Heterozygosity within populations can be calclated using *h.zygosity()* function.
|   * NOTE: A list of populations corresponding to the samples must be provided in order to plot the heterozygosity among populations.

```{r,eval=FALSE}
pops<-substr(colnames(parrot)[-c(1:9)],1,2) #population codes (the first two letters of the sample names)
hz<-h.zygosity(parrot,pops=pops)
head(hz)
```
In figure 1.3.b, we can see that most of the individuals has a mean heterozygosity (Fis) close to 1.9, except for a few outliers. However, outliers with a Fis value below -0.2 is highly likely DNA contamination. Therefore, it is recommended to remove such samples.

## 1.4 Generating allele depth tables and normalized depth values

Allele read depth table is the main data set that will be used for the rest of the analysis. Therefore, having them generated and stored for later use will immensely save a lot of time. The function *hetTgen()* is especially dedicated for this purpose. Apart from generating filtered allele depth table for separate alleles (info.type="AD"), the function can also generate total allele depth (info.type="AD-tot"), genotype table (info.type="GT"), etc.. See the help page of *hetTgen()* for more formats.

```{r,eval=FALSE}
ad.tab<-hetTgen(parrot,info.type="AD")
ad.tab[1:10,1:6]
```

Table 1.4.0 Allele depth table (generated from a different data set than parrotfish data)
```{r,echo=FALSE}
ADtable[1:6,1:6]
```

```{r,eval=FALSE}
#normalize depth table with cpm.normal()
ad.nor<-cpm.normal(ad.tab)
ad.nor[1:6,1:6]
```
Table 1.4.1 Normalized allele depth table
```{r, echo=FALSE}
ad.nor<-cpm.normal(ADtable,verbose = F)
ad.nor[1:6,1:6]
```
Compare the allele depth values between tables 1.4.0 and 1.4.1.





